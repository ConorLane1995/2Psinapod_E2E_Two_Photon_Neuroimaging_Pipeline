"""
Identify the sensitivity of individual cells to sound by examining whether they are significantly modulated by either frequency or intensity. 
Uses a two-way ANOVA on the trial activity, where one factor is frequency as was done in Gaucher et al 2020 (eLife).
Automatically handles unbalanced designs and adapts to one-way ANOVA when only one factor varies.
INPUT: cell_dictionary, recording_info for a given recording
OUTPUT: cell_dictionary with additional key ('active') denoting whether the cell was considered frequency sensitive (Boolean)
AUTHORS: Conor Lane, Veronica Tarka, May 2022, conor.lane1995@gmail.com
"""

import time
start_time = time.time()
from dataclasses import dataclass
import statsmodels.api as sm
from statsmodels.formula.api import ols
import pandas as pd
import numpy as np
import pickle
import os

# Import general functions from preprocess_utils file.
from preprocess_utils import load_config_from_json
from preprocess_utils import calculate_trial_avg

# Create a class to extract the required elements from the config.json that are used here, and load as config. 
@dataclass
class Config:
    RecordingFolder: str
    AnalysisFile: str 

# Load the required variables from config.json into the config class, only if they are listed in the class.
config = load_config_from_json(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'config.json')), Config)

BASE_PATH = config.RecordingFolder # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
TRACES_FILE = config.AnalysisFile
OUTPUT_FILE = config.AnalysisFile

def check_trial_balance(cell_trace):
    """
    Check if all frequency/intensity combinations have the same number of trials.
    
    @param cell_trace: a single cell's trials (the content of 'traces' in the cell dictionary)
    @return: tuple (is_balanced, trial_counts, min_trials)
        - is_balanced: Boolean indicating if all conditions have same number of trials
        - trial_counts: Dictionary mapping (freq, intensity) to number of trials
        - min_trials: Minimum number of trials across all conditions
    """
    trial_counts = {}
    
    for freq in cell_trace:
        for itsy in cell_trace[freq]:
            n_trials = len(cell_trace[freq][itsy])
            trial_counts[(freq, itsy)] = n_trials
    
    trial_numbers = list(trial_counts.values())
    is_balanced = len(set(trial_numbers)) == 1
    min_trials = min(trial_numbers) if trial_numbers else 0
    
    return is_balanced, trial_counts, min_trials

def subsample_balanced_traces(cell_trace, min_trials, random_seed=None):
    """
    Subsample traces to ensure all frequency/intensity combinations have the same number of trials.
    
    @param cell_trace: a single cell's trials (the content of 'traces' in the cell dictionary)
    @param min_trials: target number of trials for each condition
    @param random_seed: random seed for reproducibility (different for each cell)
    @return: subsampled_trace with equal number of trials for each condition
    """
    if random_seed is not None:
        np.random.seed(random_seed)
    
    subsampled_trace = {}
    
    for freq in cell_trace:
        subsampled_trace[freq] = {}
        for itsy in cell_trace[freq]:
            trials = cell_trace[freq][itsy]
            n_trials = len(trials)
            
            if n_trials > min_trials:
                # Get the actual trial keys (could be 1-indexed or any other scheme)
                trial_keys = list(trials.keys())
                # Randomly select min_trials from available trial keys
                selected_keys = np.random.choice(trial_keys, min_trials, replace=False)
                # Create new dictionary with selected trials, renumbered from 0
                subsampled_trace[freq][itsy] = {i: trials[key] for i, key in enumerate(selected_keys)}
            else:
                # Keep all trials but renumber them from 0
                subsampled_trace[freq][itsy] = {i: trials[key] for i, key in enumerate(trials.keys())}
    
    return subsampled_trace

def make_dataframe_from_dict(cell_trace, nFreq, nItsy, nReps):
    """
    Format the trials into a pandas dataframe as is expected by the ols method used for the ANOVA
    @param cell_trace: a single cell's trials (the content of 'traces' in the cell dictionary)
    @param nFreq: the number of unique frequencies presented
    @param nItsy: the number of unique intensities presented
    @param nReps: the number of times a unique frequency/intensity pairing was presented (or min trials if subsampled)
    @return df: a dataframe formatted such that 'activity' will store the dependent variable, and 'frequency' and 'intensity' make the two factors of the ANOVA
    """
    evoked_activity = [calculate_trial_avg(cell_trace[freq][itsy][rep])
    for freq in cell_trace
    for itsy in cell_trace[freq]
    for rep in cell_trace[freq][itsy]
    ]

    # Create frequency and intensity labels based on actual data structure
    frequencies = []
    intensities = []
    
    freq_map = {freq: idx + 1 for idx, freq in enumerate(sorted(cell_trace.keys()))}
    
    for freq in sorted(cell_trace.keys()):
        itsy_map = {itsy: idx + 1 for idx, itsy in enumerate(sorted(cell_trace[freq].keys()))}
        for itsy in sorted(cell_trace[freq].keys()):
            n_reps = len(cell_trace[freq][itsy])
            frequencies.extend([freq_map[freq]] * n_reps)
            intensities.extend([itsy_map[itsy]] * n_reps)

    return pd.DataFrame({'frequency': frequencies, 'intensity': intensities, 'activity': evoked_activity})

def is_cell_active(results):
    """
    Helper function to deduce whether a cell is either significantly modulated by frequency, or there is an interaction effect between
    frequency and intensity.
    INPUTS: Results of the ols model ANOVA.
    OUTPUTS: Boolean True/False if cell meets the p < 0.05 requirement for either condition. 
    """
    return (
        results['PR(>F)']['C(frequency)'] < 0.05 or 
        results['PR(>F)']['C(frequency):C(intensity)'] < 0.05
    )

def cell_activity_ANOVA_flexible(cell_trace, nFreq, nItsy, nReps):
    """
    Flexible ANOVA function that automatically uses one-way or two-way ANOVA as appropriate.
    
    INPUTS: cell_trace - the 'traces' section of the cell_dictionary for a given cell.
    nFreq - number of unique frequencies, nItsy - number of unique intensities, nReps - number of trials per condition
    OUTPUT: boolean of whether cell is considered sound-sensitive, the p_value of the relevant factor.
    """
    dataframe = make_dataframe_from_dict(cell_trace, nFreq, nItsy, nReps)
    
    if nItsy == 1:
        # One-way ANOVA for frequency only
        model = ols('activity ~ C(frequency)', data=dataframe).fit()
        results = sm.stats.anova_lm(model, typ=2)
        
        active = results['PR(>F)']['C(frequency)'] < 0.05
        p_value = results['PR(>F)']['C(frequency)']
        
    elif nFreq == 1:
        # One-way ANOVA for intensity only
        model = ols('activity ~ C(intensity)', data=dataframe).fit()
        results = sm.stats.anova_lm(model, typ=2)
        
        active = results['PR(>F)']['C(intensity)'] < 0.05
        p_value = results['PR(>F)']['C(intensity)']
        
    else:
        # Two-way ANOVA with interaction
        model = ols('activity ~ C(frequency) + C(intensity) + C(frequency):C(intensity)', data=dataframe).fit()
        results = sm.stats.anova_lm(model, typ=2)
        
        active = is_cell_active(results)
        p_value = results['PR(>F)']['C(frequency)']
    
    return active, p_value

def main():
    # import our recording dictionary from 1_epoch_recording
    # it's formatted like this: cell { traces { freq { intensity { repetition: trace = [x,x,x,x,...] }}}}
    with open(BASE_PATH + TRACES_FILE, 'rb') as f:
        cell_dictionary = pickle.load(f)

    # load information about our recording and stimuli
    with open(BASE_PATH + "recording_info.pkl",'rb') as f:
        recording_info = pickle.load(f)

    # extract numbers from the recording info we need later on
    nFreq = len(recording_info['frequencies'])
    nItsy = len(recording_info['intensities'])
    nReps = recording_info['nRepeats']
    
    # Check balance using the first cell only
    first_cell_id = next(iter(cell_dictionary))
    first_cell_trace = cell_dictionary[first_cell_id]['deconvolved_traces']
    is_balanced, trial_counts, min_trials = check_trial_balance(first_cell_trace)
    
    # Detect if we have only one intensity or frequency level
    unique_conditions = set(trial_counts.keys())
    unique_freqs = set(freq for freq, _ in unique_conditions)
    unique_itsys = set(itsy for _, itsy in unique_conditions)
    actual_nFreq = len(unique_freqs)
    actual_nItsy = len(unique_itsys)
    
    print(f"Detected {actual_nFreq} unique frequencies and {actual_nItsy} unique intensities.")
    
    # Determine ANOVA type
    if actual_nItsy == 1:
        print("Only one intensity level - will use one-way ANOVA for frequency.")
    elif actual_nFreq == 1:
        print("Only one frequency level - will use one-way ANOVA for intensity.")
    else:
        print("Multiple frequencies and intensities - will use two-way ANOVA.")
    
    if not is_balanced:
        print(f"Unbalanced trials detected in recording.")
        print(f"Trial counts per condition: {trial_counts}")
        print(f"Subsampling all cells to {min_trials} trials per condition.")
        use_balanced_anova = True
    else:
        print(f"Balanced design detected: {nReps} trials per condition.")
        use_balanced_anova = False
    
    active_cell_counter = 0 # initialize a counter for the number of responsive cells.
    
    for cell_idx, (cell_id, cell_data) in enumerate(cell_dictionary.items()):
        # Note: change to 'traces' here if you want the non-deconvolved trace.
        cell_trace = cell_data['deconvolved_traces']
        
        if use_balanced_anova:
            # Subsample to balance the design, using different random seed for each cell
            balanced_trace = subsample_balanced_traces(cell_trace, min_trials, random_seed=42 + cell_idx)
            active, p_value = cell_activity_ANOVA_flexible(balanced_trace, actual_nFreq, actual_nItsy, min_trials)
        else:
            # Use original ANOVA for already balanced designs
            active, p_value = cell_activity_ANOVA_flexible(cell_trace, actual_nFreq, actual_nItsy, nReps)

        cell_data['active'] = active
        cell_data['p_value'] = p_value
        if active:
            active_cell_counter += 1

    # Summary output
    print(f"Number of total cells: {len(cell_dictionary)}")
    print(f"Number of active cells: {active_cell_counter}")

    # save the dictionary with the added key ('active') to the same file
    with open(BASE_PATH+OUTPUT_FILE,'wb') as f:
        pickle.dump(cell_dictionary,f)

if __name__=="__main__":
    main()

end_time = time.time()
# Calculate the elapsed time
elapsed_time = end_time - start_time
print(f"Runtime: {elapsed_time:.2f} seconds")