"""
Identify the sensitivity of individual cells to sound by examining whether they are significantly modulated by either frequency or intensity. 
Uses a two-way ANOVA on the trial activity, where one factor is frequency as was done in Gaucher et al 2020 (eLife).
INPUT: cell_dictionary, recording_info for a given recording
OUTPUT: cell_dictionary with additional key ('active') denoting whether the cell was considered frequency sensitive (Boolean)
AUTHORS: Conor Lane, Veronica Tarka, May 2022, conor.lane1995@gmail.com
"""

import time
start_time = time.time()
from dataclasses import dataclass
import statsmodels.api as sm
from statsmodels.formula.api import ols
import pandas as pd
import numpy as np
import pickle
import os

# Import general functions from preprocess_utils file.
from preprocess_utils import load_config_from_json
from preprocess_utils import calculate_trial_avg

# Create a class to extract the required elements from the config.json that are used here, and load as config. 
@dataclass
class Config:
    RecordingFolder: str
    AnalysisFile: str 

# Load the required variables from config.json into the config class, only if they are listed in the class.
config = load_config_from_json(os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'config.json')), Config)

BASE_PATH = config.RecordingFolder # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
TRACES_FILE = config.AnalysisFile
OUTPUT_FILE = config.AnalysisFile

def make_dataframe_from_dict(cell_trace,nFreq,nItsy,nReps):

    """
    Format the trials into a pandas dataframe as is expected by the ols method used for the ANOVA
    @param cell_trace: a single cell's trials (the content of 'traces' in the cell dictionary)
    @param nFreq: the number of unique frequencies presented
    @param nItsy: the number of unique intensities presented
    @param nReps: the number of times a unique frequency/intensity pairing was presented
    @return df: a dataframe formatted such that 'activity' will store the dependent variable, and 'frequency' and 'intensity' make the two factors of the ANOVA
    """

    evoked_activity = [calculate_trial_avg(cell_trace[freq][itsy][rep])
    for freq in cell_trace
    for itsy in cell_trace[freq]
    for rep in cell_trace[freq][itsy]
    ]

    frequencies = np.repeat(np.arange(1, nFreq + 1), nItsy * nReps)
    intensities = np.tile(np.repeat(np.arange(1, nItsy + 1), nReps), nFreq)

    return pd.DataFrame({'frequency': frequencies, 'intensity': intensities, 'activity': evoked_activity})


def is_cell_active(results):

    """
    Helper function to deduce whether a cell is either significantly modulated by frequency, or there is an interaction effect between
    frequency and intensity.
    INPUTS: Results of the ols model ANOVA.
    OUTPUTS: Boolean True/False if cell meets the p < 0.05 requirement for either condition. 
    """
   
    return (
        results['PR(>F)']['C(frequency)'] < 0.05 or 
        results['PR(>F)']['C(frequency):C(intensity)'] < 0.05
    )



def cell_activity_ANOVA(cell_trace, nFreq, nItsy, nReps):

    """
    Perform ANOVA on the cell trace and return activity status (boolean) and p-value.
    INPUTS: cell_trace - the 'traces' section of the cell_dictionary for a given cell.
    nFreq - number of frequencies presented, nItsy - number of intensities, nReps - number of trials for each condition. 
    OUTPUT: boolean of whether cell is considered sound-sensitive, the p_value of the frequency factor.
    """

    dataframe = make_dataframe_from_dict(cell_trace, nFreq, nItsy, nReps)
    
    model = ols('activity ~ C(frequency) + C(intensity) + C(frequency):C(intensity)', data=dataframe).fit()

    results = sm.stats.anova_lm(model, typ=2)
    
    active = is_cell_active(results)
    p_value = results['PR(>F)']['C(frequency)']
    
    return active, p_value



def main():
    # import our recording dictionary from 1_epoch_recording
    # it's formatted like this: cell { traces { freq { intensity { repetition: trace = [x,x,x,x,...] }}}}
    with open(BASE_PATH + TRACES_FILE, 'rb') as f:
        cell_dictionary = pickle.load(f)

    # load information about our recording and stimuli
    with open(BASE_PATH + "recording_info.pkl",'rb') as f:
        recording_info = pickle.load(f)

    # extract numbers from the recording info we need later on
    nFreq = len(recording_info['frequencies'])
    nItsy = len(recording_info['intensities'])
    nReps = recording_info['nRepeats']
    

    active_cell_counter = 0 # initialize a counter for the number of responsive cells.
    
    for cell_id, cell_data in cell_dictionary.items():
        # Note: change to 'traces' here if you want the non-deconvolved trace. 
        active, p_value = cell_activity_ANOVA(cell_data['deconvolved_traces'], nFreq, nItsy, nReps)

        cell_data['active'] = active
        cell_data['p_value'] = p_value
        if active:
            active_cell_counter += 1


    # Summary output
    print(f"Number of total cells: {len(cell_dictionary)}")
    print(f"Number of active cells: {active_cell_counter}")

    # save the dictionary with the added key ('active') to the same file
    with open(BASE_PATH+OUTPUT_FILE,'wb') as f:
        pickle.dump(cell_dictionary,f)

if __name__=="__main__":
    main()

end_time = time.time()

# Calculate the elapsed time
elapsed_time = end_time - start_time
print(f"Runtime: {elapsed_time:.2f} seconds")