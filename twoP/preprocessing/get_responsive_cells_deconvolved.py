"""
Script to find sound-responsive cells by evaluating the median trial response to each condition. 
If any single condition type elicits a response that is above the threshold, the cell is considered responsive.
INPUT: Dictionary with the epoched traces
OUTPUT: Same dictionary but now with an added key "active" that holds a boolean (T if the cell is responsive)
AUTHOR: Veronica Tarka, January 2022, veronica.tarka@mail.mcgill.ca
"""

import numpy as np
import pickle
import json
import os

# load what we need from the config file
with open(os.path.abspath(os.path.dirname(__file__)) +'/../../config.json','r') as f:
    config = json.load(f)

BASE_PATH = config['RecordingFolder'] # folder with all of the files generated by Suite2P for this recording (F.npy, iscell.npy, etc)
TRACES_FILE = config['AnalysisFile']
OUTPUT_FILE = TRACES_FILE
FRAMERATE = config['RecordingFR']
EPOCH_START_IN_MS = config['EpochStart']
ZSCORE_THRESHOLD = config['zscore_threshold']

def compute_single_baseline(cell_trace,n_baseline_frames):

    nfreq = list(cell_trace.keys())
    nInt = list(cell_trace[nfreq[0]].keys())
    nrep = list(cell_trace[nfreq[0]][nInt[0]].keys())

    trials = (np.array([[[cell_trace[i][j][k] for k in nrep] for j in nInt] for i in nfreq]))
    baselines = trials[:,:,:,:n_baseline_frames]
    
    return baselines
    

"""
Redefine trial activity as z-scores relative to the baseline frames immediately preceding the stimulus
@param trial: nFrames x 1 vector of dF/F values over the trial
@param n_baseline_frames: the number of frames included in the trial epoch which preceded the stimulus
@return zscore_response: the frames occuring after the stimulus onset now defined as z-scores relative to pre-stim baseline
"""
def get_zscored_response(trial,baselines,n_baseline_frames):
    response = trial[n_baseline_frames:]

    baseline_mean = np.average(baselines)
    baseline_std = np.std(baselines)

    zscorer = lambda x: (x-baseline_mean)/baseline_std
    zscore_response = np.array([zscorer(xi) for xi in response])

    return zscore_response

"""
Check if a cell is responsive based on whether the peak of the trial average for any ONE condition type exceed the threshold
@param cell_trace: a single cell's trial activity (the contents of 'traces' in the big dictionary)
@return T/F: true if any one condition type elicited an average peak response with a z-score above threshold
"""
def check_cell_zscore(cell_trace,baselines,n_baseline_frames):
    # cell_trace is going to be all the trials of this one cell
    # {freq: intensity: repetition: [x,x,x,x,...]}}}

    for freq in cell_trace:
        for itsy in cell_trace[freq]:

            zscored_trials = []
            for rep in cell_trace[freq][itsy]:
                # convert each trial to a z-score relative to the pre-trial baseline
                zscored_trials.append(get_zscored_response(cell_trace[freq][itsy][rep],baselines,n_baseline_frames))

            # convert the matrix of trials into a np array
            zscored_trials_as_np = np.array(zscored_trials)
            
            # Take the peak value for each trial
            zscored_trials_max = np.max(zscored_trials_as_np, axis = 1)

            # Average across trials to get a 1 x Nframe vector
            zscored_trials_mean = np.mean(zscored_trials_as_np,axis=0)

            
            
           
           
            zscore_trials_thresh = zscored_trials_max[zscored_trials_max >= ZSCORE_THRESHOLD]
            zscore_trials_count = len(zscore_trials_thresh)
            
            
            # take the peak of the averaged trace
            avg_zscored_mean = np.max(zscored_trials_mean)
             # if any single condition type elicited a mean peak response above the threshold and had 4 or more responsive trials,
             # we will call the cell active
            if (avg_zscored_mean > ZSCORE_THRESHOLD) and (zscore_trials_count >= 2):
                return True

    return False
    
"""
Iterate through each cell and check whether it is sound responsive using either the STD method or z-score method
@param cell_dictionary: dictionary of cells with trace activity stored in key "traces" in each cell
@param n_baseline_frames: the number of frames included in the trial epoch that preced the stimulus onset
@return cell_dictionary: same dictionary as was input except with new key 'active' that contains T/F for whether the cell was responsive or not
""" 
def check_all_cells(cell_dictionary,n_baseline_frames):
    for cell in cell_dictionary:
        
        baselines = compute_single_baseline(cell_dictionary[cell]['deconvolved_traces'],n_baseline_frames)

        if (check_cell_zscore(cell_dictionary[cell]['deconvolved_traces'],baselines,n_baseline_frames)):# and (cell in ID_list)):
            cell_dictionary[cell]['active'] = True
        else:
            cell_dictionary[cell]['active'] = False

    return cell_dictionary

def main():
    # import our cell dictionary15
    # it's formatted like this: 181
    # cell { 'traces' { freq { intensity { repetition: [x,x,x,x,...] }}}}
    with open(BASE_PATH + TRACES_FILE, 'rb') as f:
        cell_dictionary = pickle.load(f)

    # define our pre-stim baseline we'll pass into our functions
    n_baseline_frames = round(EPOCH_START_IN_MS/1000 * FRAMERATE) * -1 #these are the frames we'll use as the baseline

    traces_with_active_boolean = check_all_cells(cell_dictionary,n_baseline_frames)

    # find the number of active cells
    counter = 0
    for cell in traces_with_active_boolean:
        if traces_with_active_boolean[cell]['active'] == True:
            counter += 1

    print('Number of total cells: {}'.format(len(cell_dictionary)))
    print("Number of active cells: {}".format(counter))

    with open(BASE_PATH+OUTPUT_FILE,'wb') as f:
        pickle.dump(traces_with_active_boolean,f)

if __name__=='__main__':
    main()